

(def function assoc-matches? (literal pattern reality assoc)
     (when (is pattern reality) (return True))
     (when (or (nil? pattern) (nil? reality)) (return False))

     (var-values [[pbit n_pattern] pattern]
		 [[rbit n_reality] reality])

     (and
      (cond
       [(symbol? pbit)
	(if (contains literal pbit)
	    then: (is pbit rbit)
	    else: (if (is (and n_pattern (car n_pattern)) '...)
		      then: {(assoc pbit reality)
			     (return True)}
		      else: {(assoc pbit rbit)
			     True}))]
       [(nil? pbit) (nil? rbit)]
       [(pair? pbit) (and (pair? rbit)
			  (assoc-matches? literal pbit rbit assoc))]
       [else: (== pbit rbit)])

      (assoc-matches? literal n_pattern n_reality assoc)))


(def function matches? (literal pattern reality)
     (var [bindings (#dict)]
	  [assoc bindings.__setitem__])

     (and (assoc-matches? literal pattern reality assoc) bindings))


(def function syntax-translate (swaptable pattern)

     (when (symbolish? pattern)
       (return
	(if (in pattern swaptable)
	    then: (cons unquote (! get swaptable pattern) nil)
	    else: pattern)))

     (when (or (nil? pattern) (not (pair? pattern)))
       (return pattern))

     (define elli '...)

     (labels
      [[swapfn [v] (! get swaptable v v)]

       [swapit [follower head tail]
	(cond
	 [(symbolish? head)
	  (if (in head swaptable)
	      then: (if (and tail (is (car tail) elli))
			then: { (next follower)
				(cons 'unquote-splicing (swapfn head) nil) }
			else: (cons 'unquote (swapfn head) nil))
	      else: head)]
	 [(and (pair? head) (not (nil? head)))
	  (translate  head)]
	 [else: head])]

       [translate [pat]
	 (var [result (copy pat)]
	      [follower (! follow result)])
	 (for-each [p follower]
	    (unless (nil? p)
	      (define-values [head tail] p)
	      (setf (car p) (swapit follower head tail))))
	 result]]

      (cons 'quasiquote (translate pattern) nil)))


(def class SyntaxRules []
     (def function __init__ [self literals rules]
	  (print "init SyntaxRules")
	  (print "  literals" (repr literals))
	  (print "  rules" (repr rules))

	  ;; compile each rule into a matcher and a transformation
	  (setf self.literals literals)
	  (setf self.rules rules))

     (def function match [self source]
	  (var [literal self.literals]
	       [bound None]
	       [rules self.rules])
	  (for-each [[pattern transform] rules]
	      (print "  checking pattern" (str pattern))
	      (setq bound (matches? literal (cdr pattern) source))
	      (when bound
		(print "  bound" (repr bound))
		(break (#tuple bound transform)))))

     (def function __call__ [self source]
	  (print "trying to match")
	  (print "  source" (repr source))

	  ;; for each rule in self rules
	  ;; if rule matches, apply rule, return result
	  ;; finally raise syntax error

	  (define found (self.match (cdr source)))
	  (when found
	    (print "  found" (repr found))
	    (define-values [bound transform] found)
	    (transform **: (dict (#gen [[k v] (! items bound)]
				       `(,(str k) . ,v))))))

     ; end of class SyntaxRules
     None)


(def function foo [left right: 0]
  (print "foo" left right)
  (+ left right))


;; these should go into basics ASAP

(def function pair-walk (cpair callback)
     (unless (nil? cpair)
       (define-values [head tail] cpair)
       (when (cond
	      [(nil? head) True]
	      [(pair? head) (pair-walk head callback)]
	      [else: (callback head tail)])
	 (pair-walk tail callback))))


(def function iter-pair-walk (cpair)
     (until (nil? cpair)
       (define-values [head tail] cpair)
       (cond
	[(nil? head) None]
	[(pair? head) (yield-from (iter-pair-walk head))]
	[else: (yield head)])
       (setq cpair tail)))


(defmacro syntax-error! [msg]
  `(raise! SyntaxError ,msg))


(defmacro syntax-rule [literals pattern transform]
  (var [hygenic (#dict)]
       [elli '...]
       [literals (set (literals.unpack))])

  (print "syntax-rule")
  (print "  literals" (repr literals))
  (print "  pattern" (str pattern))
  (print "  transform" (str transform))

  (labels
   [[collect [head tail]
       (print "collect")
       (print "  head" (str head))
       (print "  tail" (str tail))
       (when (and (symbol? head)
		  (is-not elli head)
		  (not-in head literals))
	 (if (in head hygenic)
	     then: (syntax-error! (#fmt "duplicate binding {head}"))
	     else: (setf (item hygenic head) (gensym head))))
       True]]


   (pair-walk (cdr pattern) collect)
   (print "  hygenic" (repr hygenic))

   `(function
     syntax-transform [,@(! keys hygenic)]
     (print "syntax-transform")
     (print "   locals" (locals))
     (print "   transform" ,(str transform))
     `(,,@(syntax-translate hygenic transform)))))


(defmacro define-syntax-rules [name literals . sr]
  (print "define-syntax-rules")
  (print "  literals" (repr literals))
  (print "  sr" (str sr))

  (var [rules (map unpack sr)]
       [csr (#lc [[pattern transform] rules]
	       `(#tuple
		 ',pattern
		 (syntax-rule ,literals ,pattern ,transform)))])

  (print "  csr" (repr csr))
  `(define ,name
     (syntax ,(str name) (SyntaxRules ',literals
				      (#tuple ,@csr)))))


(define-syntax-rules foo! ()
  [[foo! a b ...]
   (reduce foo (#tuple a b ...))]
  [[foo! a]
   (foo a)])


(foo! 1 2 3)
(foo! 1)
(foo!)


;; The end.
